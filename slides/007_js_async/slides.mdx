export { default as theme } from '../src/wizeline-theme'
import { CodeSurfer } from "mdx-deck-code-surfer"
import { Notes } from 'mdx-deck'

import {WSlideMain, WSlide2, WSlide3, WSlide4, WSlide5, WSlideThankyou} from "../src/wizeline-theme/slides"
import {WLayout1, WLayout2} from '../src/wizeline-theme/layouts'
import { Split } from 'mdx-deck/layouts'

import Counter from '../src/components/Counter'
import Codepen from '../src/components/Codepen'

<WSlideMain
  subtitle=""
  title="JS Async Programming"
/>

---

<WSlide2
  title="Content"
  title2=""
  content1="Event Loop"
  content2="Callbacks"
  content3="Promises"
  content4="Async/Await"
/>

---

<WSlide3
  title="What is the event loop?"
/>

---

export default WLayout1

# Quick quiz...

---

<Codepen url="https://codepen.io/orverduzco/pen/KGrYax"/>

---

export default WLayout1

# Event Loop.
### The event loop is the way the JS engine handles the execution of all the statements that need to go into the message queue. Don't worry, I'll explain this later.

---

export default WLayout1

## The runtime is composed by: 
- The call stack.
- The Heap
- The Queue
- The event loop

---

export default WLayout1

## The Heap: 
### It's a place in memory where objects are stored.

---

export default WLayout1

## The Call Stack: 
### It's where all the statements declared in the code are stacked and executed.

---

export default WLayout1

## The Queue: 
### It's where messages "to be processed" (aka async) go. 

---
export default WLayout1

## The Event Loop: 
### Everytime the Call Stack is emptied, the event loop checks the Queue and, if there are any messages pending to be processed, inserts them one by one into the call stack. 

---

![event-loop](./images/event-loop.gif)

---

export default WLayout1

http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7Cgo%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D

---

export default WLayout1

## Any ideas why it was designed to be like this?

---

export default WLayout1

# Non-blocking execution in the browser

---

export default WLayout1

## What are those `Web APIs` and how do they work?

---

export default WLayout1

## They are not part of the JS spec. They are a part of the runtime that interacts with the broswer's hosting environment doing OS-level operations. Once done, they return to the JS runtime with a result and queue the callback with the result.

---

export default WLayout1

### `setTimeout()` is not part of the JS specification, but most runtime environments provide it as part of the API.

---

export default WLayout1

### What else did you notice in the `setTimeout` function?

---
export default WLayout1

### It is a higher order function, and it uses one of the mechanisms in JS to handle async operations.

---

<WSlide3
  title="Callbacks"
/>

---

export default WLayout1

## Quiz...
### How would you define a callback?
### Are callbacks async on their own?
### Let's see...

---

<Codepen url="https://codepen.io/orverduzco/pen/BqGEdJ"/>

---

export default WLayout1

### NO. Callbacks is just a way to indicate what to do whenever the real async operation is complete. Callbacks are nothing but a function passed as a parameter thanks to the ability to have higher order functions.

---

export default WLayout1

### Is there a way to make JS block the main (and only) thread? Let's see...
### (btw, JS is single-threaded.)

---

<Codepen url="https://codepen.io/orverduzco/pen/ZqmZBw"/>

---

export default WLayout1

### JS engine executes your code in chunks, but all chunks are run to completion (unless interrupted).
### Can we use a callback to solve the previous problem? Let's see...

---

<Codepen url="https://codepen.io/orverduzco/pen/pxQBgZ"/>

---

export default WLayout1

### This varies between runtime environments, but generally, you can block the main thread using functions that take very long to execute. It's up to the environment to decide what to do.

---

export default WLayout1

### What is truly unblocking are the Web APIs. They are designed to interact with the hosting environment of the browser and make sure that they will execute in an efficient way, and always return a result.

---

export default WLayout1

### BE AWARE that it's up to you what to do with the callback. A Callback can block the main thread.

---

<WSlide3
  title="Callback Hell"
/>

---

export default WLayout1

### Can someone tell me what the callback hell is?

---

<Codepen url="https://codepen.io/orverduzco/pen/PyxvMM"/>

---

export default WLayout1

### This is called the pyramid of doom. You can create a pyramid-like shape with all those nested callbacks.

---

export default WLayout1

### Is that all there is to the callback hell? It's a big part, but not all of it.

---

![callback-hell-1](./images/callback-hell-1.png)

---

![callback-hell-2](./images/callback-hell-2.png)

---

export default WLayout1

# Trust issues.

---

<Codepen url="https://codepen.io/orverduzco/pen/pxQMEO"/>

---

export default WLayout1

## Quick Recap

- Event loop - how async stuff is queued.
- Callbacks.
- Callback Hell.

---

<WSlide3
  title="Promises"
/>

---

export default WLayout1

## Who can tell me what a promise is?

---

<WSlide3
  title="Q&A"
/>

---
<WSlideThankyou/>
