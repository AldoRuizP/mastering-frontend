export { default as theme } from "../src/wizeline-theme";
import { Notes } from "mdx-deck";
import { CodeSurfer } from "mdx-deck-code-surfer";
import { WAgenda, WSlideMain, WSlide3 as WFullPage, WSlide4 as WSection, WSlideThankyou } from "../src/wizeline-theme/slides";
import { WAnimateListBlack, WStaticBlack, WStaticRed } from "../src/wizeline-theme/layouts";
import Codepen from "../src/components/Codepen";

<WSlideMain
  subtitle=""
  title="CSS Fundamentals"
/>

<Notes>
The purpose of this session is to familiarize yourself with the fundamentals of CSS.
</Notes>

---

<WFullPage title="Introduction" />

<Notes>
I'm Isabel, I joined Wize three years ago, the same number of years I have developed frontend.
I remember that when I first interviewed for Wize Services,Ô∏è I had no idea of what frontend really was.
Of course, this being a startup, my first project was frontend, and also all the following.
But, I started to really respect and love frontend development, so I hope I can help you with your journey.
</Notes>

---

<WAgenda
  title="Agenda"
  subtitle="CSS Fundamentals"
  content={[
    "CSS Introduction",
    "Selectors",
    "Cascading and Inheritance",
    "Box Model",
    "References"
  ]}
/>

<Notes>
This is the agenda for this presentation.
First, I'll talk about CSS fundamentals, so that we are in the same page.
Today we will only cover till here.
Then I'll talk about Cascading and Inheritance, then about Selectors
and Specificity, and then about the Box Model.
Finally I'll give you some references from which you can learn more about CSS üíñ.
Between every section there would be time for questions, in case you have any.
</Notes>

---

<WSection title="CSS Introduction" />

---

export default WAnimateListBlack

## Introduction to CSS


* Cascading Style Sheets

* First released in 1996

* Declarative language

<Notes>
>> CSS means "Cascading Style Sheets", we wil talk about what is cascading later on.
>> It was first release in 1996, the same year as Java btw, more than 20 years ago.
>> Is a declarative language, that means that you describe what you want to achieve, not how.
I can say "I want the background to be red", and I don't care how the browser does that internally. >>
</Notes>

---

export default WStaticRed

## Introduction to CSS

* Cascading Style Sheets

* First released in 1996

* Declarative language

---

export default WStaticBlack

## CSS Rule Syntax

<CodeSurfer
  code={require("!raw-loader!./snippets/rule-components.css")}
  lang="css"
  showNumbers={false}
  dark={true}
  steps={[
    { tokens: { 1: [0] }, notes: "Selector" },
    { tokens: { 1: [2] }, lines: [2,3,4,5], notes: "Declaration block" },
    { lines: [2], notes: "Declaration" },
    { tokens: { 2: [1] }, notes: "Property" },
    { tokens: { 2: [4] }, notes: "Value" }
  ]}
/>

<Notes>
CSS most basic construct, is the CSS _rule_ or _ruleset_. This is one example of it.
I'll name its parts so that we all know how to call them.
>> All CSS rules have a _selector_ that indicate to which elements to apply the rule.
>> Then other part of a rule is the _declaration block_ that says what style to apply to the selected elements.
>> The declaration block has several _declarations_.
>> Each declaration has a _property_, followed by a colon, >> and a _value_, followed by a semicolon.
There are other CSS statements, such as the _at-rules_, but they'll be introduced later on.
</Notes>

---

<WFullPage title="Questions?" />

---

<WSection title="Selectors" />

---

export default WAnimateListBlack

## Selectors

<CodeSurfer
  code={require("!raw-loader!./snippets/button.html")}
  lang="html"
  showNumbers={false}
  dark={true}
  steps={[
    { tokens: { 1: [1] } },
    { tokens: { 1: [3,4,5,6,7] } },
    { tokens: { 1: [9,10,11,12,13] } },
    { tokens: { 1: [15,16,17,18,19] } },
    { lines: [2] },
    { lines: [1,2,3,4] },
    { lines: [1,2,3,4] }
  ]}
/>

* Element type `button`
* Id `#save-changes`
* CSS class `.main`
* Attribute `[type=primary]`
* Pseudo-elements `::before`
* Pseudo-classes `:hover`
* Universal `*`

<Notes>
Selectors define a set of elements to which to apply the styling.
In CSS there are a lot of different ways to select elements.
For example, if we had this element, to select it we could use
>> its type `button`, >> its id `save-changes-btn`, >> its class `main-button.
There are also other selectors for pseudo elements, >> like the before. This is not an element in the HTML, but acts like one.
And finally there are also the pseudo-classes >> like the `hover`, `last-child`, etc.
These selectors can be combined to modify the set of selected elements.
</Notes>

---

export default WAnimateListBlack

## Combining Selectors

* JavaScript
    ```js
    if (elem.type === 'h1') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    h1 {
      color: red;
    }
    ```

<Notes>
Combining selectors is similar to set operations, but we can also relate them to boolean operations in conditionals.
>> An `if` like this would translate to this CSS rule. >>
</Notes>

---

export default WAnimateListBlack

## Combining Selectors
#### Intersection

* JavaScript
    ```js
    if (elem.type === 'h1' && elem.class === 'title') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    h1.title {
      color: red;
    }
    ```

<Notes>
For intersection, we want to reduce the set of elements selected.
>> For JavaScript this would be an `&&` >> in CSS you put the selectors together with no spaces.
This selector will apply to all `h1` with the class `title.
</Notes>
---

export default WAnimateListBlack

## Combining Selectors
#### Union
* JavaScript
    ```js
    if (elem.type === 'h1' || elem.type === 'h2') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    h1, h2 {
      color: red;
    }
    ```

<Notes>
For a union, we want to select elements that meet both criteria.
>> For JavaScript this would be an `||` >> in CSS you use a comma.
This selector will apply to all `h1` and all `h2`.
</Notes>
---

export default WAnimateListBlack

## Combining Selectors
#### Difference
* JavaScript
    ```js
    if (elem.type !== 'h2') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    :not(h2) {
      color: red;
    }
    ```

<Notes>
For the difference, we want to select elements that don't meet the criteria.
>> For JavaScript this would be a `!` >> and in CSS you use a the pseudo-class `:not`.
This selector will apply to all elements not `h2`s.
</Notes>
---

export default WStaticBlack

## Combinators and Pseudo-classes

<CodeSurfer
  code={require("!raw-loader!./snippets/combinators.html")}
  lang="markup"
  showNumbers={false}
  dark={true}
  steps={[
    { lines: [4,6], notes: "Adjacent elements: span + a" },
    { lines: [4,6,7,8,9], notes: "Sibling elements: span ~ a" },
    { lines: [3], notes: "Direct child: section > span" },
    { lines: [3,5], notes: "Descendant: section span" },
    { lines: [2,5], notes: "section :first-child" },
    { lines: [5,7,8,9], notes: "section :last-child" },
    { lines: [4,6], notes: "section :nth-child(3)" },
    { lines: [2,3,5], notes: "section :first-of-type" },
    { lines: [3,5,7,8,9], notes: "section :last-of-type" }
  ]}
/>

<Notes>
Combinators help us select elements based on their relation to other nodes. >>
The plus sign is for direct siblings, >> the tilde for any _next_ sibling.
>> The greater-than sign is for direct children, and the space for descendants.
There are also some pseudo-classes to select element based on the DOM order.
>> The first-child or >> last-child select the first or last node.
>> To select an element in an specific position, use the nth-child pseudo-class.
>> The first-of-type or >> the last-of-type, select the first or last per each type.
</Notes>

---

export default WStaticBlack

## Combinators and Pseudo-classes

<CodeSurfer
  code={require("!raw-loader!./snippets/combinators-tree.txt")}
  lang="markup"
  showNumbers={false}
  dark={true}
  steps={[
    { tokens: { 5: [9,10,11] }, notes: "Adjacent elements: span + a" },
    { tokens: { 5: [9,10,11,  13,14,15] }, notes: "Sibling elements: span ~ a" },
    { tokens: { 5: [5,6,7] }, notes: "Direct child: section > span" },
    { tokens: { 5: [5,6,7], 7: [1,2,3] }, notes: "Descendant: section span" },
    { tokens: { 5: [1,2,3], 7: [1,2,3] }, notes: "section :first-child" },
    { tokens: { 5: [13,14,15], 7: [1,2,3] }, notes: "section :last-child" },
    { tokens: { 5: [9,10,11] }, notes: "section :nth-child(3)" },
    { tokens: { 5: [1,2,3,  5,6,7], 7: [1,2,3] }, notes: "section :first-of-type" },
    { tokens: { 5: [5,6,7,  13,14,15], 7: [1,2,3] }, notes: "section :last-of-type" }
  ]}
/>

<Notes>
You can also think of the HTML as a tree. This is how each of the previous
combinators and pseudo-classes are selected.
</Notes>
---

<Codepen url="https://codepen.io/isa-bel/pen/zmPYBL"/>

<Notes>
_Leave presenters mode_
</Notes>

---

<WFullPage title="Questions?" />

