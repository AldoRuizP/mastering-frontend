export { default as theme } from "../src/wizeline-theme";
import { Notes } from "mdx-deck";
import { CodeSurfer } from "mdx-deck-code-surfer";
import { WAgenda, WSlideMain, WSlide3 as WFullPage, WSlide4 as WSection, WSlideThankyou } from "../src/wizeline-theme/slides";
import { WAnimateListBlack, WStaticBlack, WStaticRed } from "../src/wizeline-theme/layouts";
import Codepen from "../src/components/Codepen";

<WSlideMain
  subtitle=""
  title="CSS Fundamentals"
/>

<Notes>
The purpose of this session is to familiarize yourself with the fundamentals of CSS.
</Notes>

---

<WFullPage title="Introduction" />

<Notes>
I'm Isabel, I joined Wize three years ago, the same number of years I have developed frontend.
I remember that when I first interviewed for Wize Services,Ô∏è I had no idea of what frontend really was.
Of course, this being a startup, my first project was frontend, and also all the following.
But, I started to really respect and love frontend development, so I hope I can help you with your journey.
</Notes>

---

<WAgenda
  title="Agenda"
  subtitle="CSS Fundamentals"
  content={[
    "CSS Introduction",
    "Selectors",
    "Cascading and Inheritance",
    "Box Model",
    "References"
  ]}
/>

<Notes>
This is the agenda for this presentation.
First, I'll talk about CSS fundamentals, so that we are in the same page.
Today we will only cover till here.
Then I'll talk about Cascading and Inheritance, then about Selectors
and Specificity, and then about the Box Model.
Finally I'll give you some references from which you can learn more about CSS üíñ.
Between every section there would be time for questions, in case you have any.
</Notes>

---

<WSection title="CSS Introduction" />

---

export default WAnimateListBlack

## Introduction to CSS


* Cascading Style Sheets

* First released in 1996

* Declarative language

<Notes>
>> CSS means "Cascading Style Sheets", we wil talk about what is cascading later on.
>> It was first release in 1996, the same year as Java btw, more than 20 years ago.
>> Is a declarative language, that means that you describe what you want to achieve, not how.
I can say "I want the background to be red", and I don't care how the browser does that internally. >>
</Notes>

---

export default WStaticRed

## Introduction to CSS

* Cascading Style Sheets

* First released in 1996

* Declarative language

---

export default WStaticBlack

## CSS Rule Syntax

<CodeSurfer
  code={require("!raw-loader!./snippets/rule-components.css")}
  lang="css"
  showNumbers={false}
  dark={true}
  steps={[
    { tokens: { 1: [0] }, notes: "Selector" },
    { tokens: { 1: [2] }, lines: [2,3,4,5], notes: "Declaration block" },
    { lines: [2], notes: "Declaration" },
    { tokens: { 2: [1] }, notes: "Property" },
    { tokens: { 2: [4] }, notes: "Value" }
  ]}
/>

<Notes>
CSS most basic construct, is the CSS _rule_ or _ruleset_. This is one example of it.
I'll name its parts so that we all know how to call them.
>> All CSS rules have a _selector_ that indicate to which elements to apply the rule.
>> Then other part of a rule is the _declaration block_ that says what style to apply to the selected elements.
>> The declaration block has several _declarations_.
>> Each declaration has a _property_, followed by a colon, >> and a _value_, followed by a semicolon.
There are other CSS statements, such as the _at-rules_, but they'll be introduced later on.
</Notes>

---

<WFullPage title="Questions?" />

---

<WSection title="Selectors" />

---

export default WAnimateListBlack

## Selectors

<CodeSurfer
  code={require("!raw-loader!./snippets/button.html")}
  lang="html"
  showNumbers={false}
  dark={true}
  steps={[
    { tokens: { 1: [1] } },
    { tokens: { 1: [3,4,5,6,7] } },
    { tokens: { 1: [9,10,11,12,13] } },
    { tokens: { 1: [15,16,17,18,19] } },
    { lines: [2] },
    { lines: [1,2,3,4] },
    { lines: [1,2,3,4] }
  ]}
/>

* Element type `button`
* ID `#save-changes`
* CSS class `.main`
* Attribute `[type=primary]`
* Pseudo-elements `::before`
* Pseudo-classes `:hover`
* Universal `*`

<Notes>
Selectors define a set of elements to which to apply the styling.
In CSS there are a lot of different ways to select elements.
For example, if we had this element, to select it we could use
>> its type `button`, >> its ID `save-changes-btn`, >> its class `main-button.
There are also other selectors for pseudo elements, >> like the before. This is not an element in the HTML, but acts like one.
And finally there are also the pseudo-classes >> like the `hover`, `last-child`, etc.
These selectors can be combined to modify the set of selected elements.
</Notes>

---

export default WAnimateListBlack

## Combining Selectors

* JavaScript
    ```js
    if (elem.type === 'h1') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    h1 {
      color: red;
    }
    ```

<Notes>
Combining selectors is similar to set operations, but we can also relate them to boolean operations in conditionals.
>> An `if` like this would translate to this CSS rule. >>
</Notes>

---

export default WAnimateListBlack

## Combining Selectors
#### Intersection

* JavaScript
    ```js
    if (elem.type === 'h1' && elem.class === 'title') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    h1.title {
      color: red;
    }
    ```

<Notes>
For intersection, we want to reduce the set of elements selected.
>> For JavaScript this would be an `&&` >> in CSS you put the selectors together with no spaces.
This selector will apply to all `h1` with the class `title.
</Notes>
---

export default WAnimateListBlack

## Combining Selectors
#### Union
* JavaScript
    ```js
    if (elem.type === 'h1' || elem.type === 'h2') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    h1, h2 {
      color: red;
    }
    ```

<Notes>
For a union, we want to select elements that meet both criteria.
>> For JavaScript this would be an `||` >> in CSS you use a comma.
This selector will apply to all `h1` and all `h2`.
</Notes>
---

export default WAnimateListBlack

## Combining Selectors
#### Difference
* JavaScript
    ```js
    if (elem.type !== 'h2') {
        elem.color = 'red';
    }
    ```
* CSS
    ```css
    :not(h2) {
      color: red;
    }
    ```

<Notes>
For the difference, we want to select elements that don't meet the criteria.
>> For JavaScript this would be a `!` >> and in CSS you use a the pseudo-class `:not`.
This selector will apply to all elements not `h2`s.
</Notes>
---

export default WStaticBlack

## Combinators and Pseudo-classes

<CodeSurfer
  code={require("!raw-loader!./snippets/combinators.html")}
  lang="markup"
  showNumbers={false}
  dark={true}
  steps={[
    { lines: [4,6], notes: "Adjacent elements: span + a" },
    { lines: [4,6,7,8,9], notes: "Sibling elements: span ~ a" },
    { lines: [3], notes: "Direct child: section > span" },
    { lines: [3,5], notes: "Descendant: section span" },
    { lines: [2,5], notes: "section :first-child" },
    { lines: [5,7,8,9], notes: "section :last-child" },
    { lines: [4,6], notes: "section :nth-child(3)" },
    { lines: [2,3,5], notes: "section :first-of-type" },
    { lines: [3,5,7,8,9], notes: "section :last-of-type" }
  ]}
/>

<Notes>
Combinators help us select elements based on their relation to other nodes. >>
The plus sign is for direct siblings, >> the tilde for any _next_ sibling.
>> The greater-than sign is for direct children, and the space for descendants.
There are also some pseudo-classes to select element based on the DOM order.
>> The first-child or >> last-child select the first or last node.
>> To select an element in an specific position, use the nth-child pseudo-class.
>> The first-of-type or >> the last-of-type, select the first or last per each type.
</Notes>

---

export default WStaticBlack

## Combinators and Pseudo-classes

<CodeSurfer
  code={require("!raw-loader!./snippets/combinators-tree.txt")}
  lang="markup"
  showNumbers={false}
  dark={true}
  steps={[
    { tokens: { 5: [9,10,11] }, notes: "Adjacent elements: span + a" },
    { tokens: { 5: [9,10,11,  13,14,15] }, notes: "Sibling elements: span ~ a" },
    { tokens: { 5: [5,6,7] }, notes: "Direct child: section > span" },
    { tokens: { 5: [5,6,7], 7: [1,2,3] }, notes: "Descendant: section span" },
    { tokens: { 5: [1,2,3], 7: [1,2,3] }, notes: "section :first-child" },
    { tokens: { 5: [13,14,15], 7: [1,2,3] }, notes: "section :last-child" },
    { tokens: { 5: [9,10,11] }, notes: "section :nth-child(3)" },
    { tokens: { 5: [1,2,3,  5,6,7], 7: [1,2,3] }, notes: "section :first-of-type" },
    { tokens: { 5: [5,6,7,  13,14,15], 7: [1,2,3] }, notes: "section :last-of-type" }
  ]}
/>

<Notes>
You can also think of the HTML as a tree. This is how each of the previous
combinators and pseudo-classes are selected. Here is easier to notice that there
are no lookahead selectors. This means that you cannot select a parent node via its children,
nor you cannot select an element via its next sibling. _show in the tree_
</Notes>
---

<Codepen url="https://codepen.io/isa-bel/pen/zmPYBL"/>

<Notes>
_Leave presenters mode_
</Notes>

---

<WFullPage title="Questions?" />

---

<WSlideMain
  subtitle=""
  title="CSS Fundamentals"
  subtitle="Part 2"
/>

---

export default WStaticBlack

## Selectors Recap

* Element type `button`
* Id `#save-changes`
* CSS class `.main`
* Attribute `[type=primary]`
* Pseudo-elements `::before`
* Pseudo-classes `:hover`

CSS cheatsheet: [https://devhints.io/css](https://devhints.io/css)

<Notes>
During this session we will create styles for a night-mode for GitHub.
_open https://github.com/wizelineacademy/mastering-frontend_
</Notes>
---

<WSection title="Cascading and" title2="Inheritance" />

---

export default WStaticBlack

## The Cascade

> Whether you write custom CSS or use a framework, pick original selectors every time or build a component-based system, use CSS as intended or inject it all inline via CSS-in-JS ‚Äî ‚Ä¶ in every case, you are relying on the cascade. Which is a very good thing.

> Without the cascading nature of CSS, you‚Äôd have to declare every single property in every single element. And when new CSS shipped, you‚Äôd have to go back old websites and add the new properties to every element. Now THAT would be stupid. We count on the cascade. Understand it.

> -- [Jen Simmons, Designer Advocate at Mozilla](https://twitter.com/jensimmons/status/1039166001013825536)

<Notes>
I would like to start with this quote by Jen Simmons.
She is a Designer Advocate at Mozilla and creates a lot of CSS related content, especially of the new CSS features.
_read the quote_
An incomplete understanding of the cascade can get you into trouble _very_ quickly.
Understanding it will help you write maintainable CSS, with less `!important`s.
</Notes>

---

export default WAnimateListBlack

## The Cascade

* Determines which styles to apply to an element.
* Which style ‚Äúwins‚Äù and gets applied.

<Notes>
The cascade is the mechanism that controls which rules are applied to an element.
Is close to the OOP concept of inheritance.
</Notes>

---

export default WStaticBlack

## OOP Inheritance

![inheritance](./images/inheritance.svg)

<Notes>
This is an example of inheritance. If the parent declares a property, the children can inherit it or override it.
The problem comes with whats is known as the Diamond Problem.
</Notes>

---

export default WStaticBlack

## The Diamond Problem

![deadly diamond of death](./images/diamond.svg)

<Notes>
This originates when a child has two or more parents that share an ancestor.
Which of the implementations of `cookingMethod` will `cronut` have?
Java solves this problem by disabling multiple inheritance.
</Notes>

---

export default WAnimateListBlack

## Cascade Tiebreakers

To decide which style to apply, the cascade uses these three attributes:

1. Importance
2. Specificity
3. Source order

<Notes>
CSS uses three attributes to break the tie:
_importance_: >> If the rule uses the `!important` declaration.
_specificity_: >> How specific the selectors of the rule are.
and _order_: >> The order of declaration.
</Notes>

---

<WFullPage title="Questions?" />

---

export default WAnimateListBlack

## Importance and Order

* Declarations followed by the `!important` declaration.
*    ```
    color: red !important;
    ```
* The order of stylesheets, rules, and declarations.
*    ```
    color: red;
    color: black;
    ```
* What will happen here?
    ```
    color: red !important;
    color: black;
    ```

<Notes>
_Show examples for importance and order_.
</Notes>

---

export default WAnimateListBlack

## Specificity

* 1000 Inline styles
*    ```
    <div style="color: red;">
    ```
* _100 IDs
*    ```
    #id
    ```
* __10 class, attribute, or pseudo-class
*    ```
    .class [attr] :first-of-type
    ```
* ___1 element or pseudo-element
*    ```
    div ::before
    ```

<Notes>
> A class selector beats any number of element selectors
> The latest rule wins
> The universal selector has a specificity of 0, 0, 0, 0
> !important adds 5th and the highest level of specificity.
_Show examples for specificity with CSSDig_.
TODO: add React component?
TODO: add a slide with Specificity best practices?
</Notes>

---

<WFullPage title="Questions?" />

---

export default WAnimateListBlack

## CSS Inheritance

If no value is assigned for a property, get the value of the parent.

* Not all properties are inherited, `border`.
* Use the `inherit` keyword to override other rules.
* For non-inherited properties, use `initial` to reset them.

<Notes>
> In CSS, inheritance controls what happens when no value is specified for a property on an element.
</Notes>

---

<WFullPage title="Questions?" />

---

<WSlideThankyou/>